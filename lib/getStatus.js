// Generated by CoffeeScript 2.3.0
var Finder, assertValid, escapeStringRegExp, exec, findNewPath, findPath, findStagingStatus, findWorkingStatus, getLocalStatus, getRemoteStatus, git, optionTypes, os, statusMap;

escapeStringRegExp = require("escape-string-regexp");

assertValid = require("assertValid");

Finder = require("finder");

exec = require("exec");

os = require("os");

git = require("./core");

optionTypes = {
  raw: "boolean?",
  remote: "boolean?"
};

module.exports = git.getStatus = function(repo, opts = {}) {
  assertValid(repo, String);
  assertValid(opts, optionTypes);
  if (opts.remote) {
    return getRemoteStatus(repo);
  } else {
    return getLocalStatus(repo, opts);
  }
};

getRemoteStatus = async function(repo) {
  var findAhead, findBehind, findRemoteBranch, stdout;
  stdout = (await exec("git status --short --branch --porcelain", {
    cwd: repo
  }));
  stdout = stdout.split(os.EOL)[0];
  findRemoteBranch = Finder(/\.\.\.([^\s]+)/);
  findAhead = Finder("ahead ([0-9]+)");
  findBehind = Finder("behind ([0-9]+)");
  return {
    branch: findRemoteBranch(stdout),
    ahead: Number(findAhead(stdout)),
    behind: Number(findBehind(stdout))
  };
};

getLocalStatus = async function(repo, opts) {
  var base, base1, file, files, i, len, line, ref, results, stagingStatus, status, stdout, workingStatus;
  stdout = (await exec("git status --porcelain", {
    cwd: repo
  }));
  if (opts.raw) {
    return stdout;
  }
  results = {
    staged: {},
    tracked: {},
    untracked: [],
    unmerged: []
  };
  if (!stdout.length) {
    return results;
  }
  ref = stdout.split(os.EOL);
  for (i = 0, len = ref.length; i < len; i++) {
    line = ref[i];
    file = {
      path: findPath(line)
    };
    stagingStatus = findStagingStatus(line);
    workingStatus = findWorkingStatus(line);
    // Pretend "copied" files are simply "added".
    if (stagingStatus === "C") {
      stagingStatus = "A";
      file.path = findNewPath(line);
    }
    if ((stagingStatus === "?") && (workingStatus === "?")) {
      results.untracked.push(file);
      continue;
    }
    if ((stagingStatus === "U") && (workingStatus === "U")) {
      results.unmerged.push(file);
      continue;
    }
    if ((stagingStatus === "R") || (workingStatus === "R")) {
      file.newPath = findNewPath(line);
      file.oldPath = file.path;
      delete file.path;
    }
    if ((stagingStatus !== " ") && (stagingStatus !== "?")) {
      if (!(status = statusMap[stagingStatus])) {
        throw Error("Unrecognized status!");
      }
      files = (base = results.staged)[status] || (base[status] = []);
      files.push(file);
    }
    if ((workingStatus !== " ") && (workingStatus !== "?")) {
      if (!(status = statusMap[workingStatus])) {
        throw Error("Unrecognized status!");
      }
      files = (base1 = results.tracked)[status] || (base1[status] = []);
      files.push(file);
    }
  }
  return results;
};

statusMap = {
  "A": "added",
  "C": "copied",
  "R": "renamed",
  "M": "modified",
  "D": "deleted",
  "U": "unmerged",
  "?": "untracked"
};

({findStagingStatus, findWorkingStatus, findPath, findNewPath} = (function() {
  var charRegex, chars, regex;
  chars = Object.keys(statusMap);
  charRegex = "([" + escapeStringRegExp(chars.join("")) + "\\s]{1})";
  regex = RegExp([
    "^[\\s]*",
    charRegex, // The 'staging status'
    charRegex, // The 'working status'
    " ",
    "([^\\s]+)", // The 'path'
    "( -> ([^\\s]+))?" // The 'new path' (optional)
  ].join(""));
  return {
    findStagingStatus: Finder({
      regex,
      group: 1
    }),
    findWorkingStatus: Finder({
      regex,
      group: 2
    }),
    findPath: Finder({
      regex,
      group: 3
    }),
    findNewPath: Finder({
      regex,
      group: 5
    })
  };
})());
