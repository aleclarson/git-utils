// Generated by CoffeeScript 2.3.0
var assertValid, exec, git, optionTypes, os;

assertValid = require("assertValid");

exec = require("exec");

os = require("os");

require("./getBranch");

git = require("./core");

optionTypes = {
  force: "boolean?",
  remote: "string?",
  branch: "string?",
  keyPath: "string?",
  upstream: "boolean?",
  listener: "function?"
};

module.exports = git.pushBranch = async function(repo, opts = {}) {
  var args, branch, env, err, regex;
  assertValid(repo, "string");
  assertValid(opts, optionTypes);
  branch = (await git.getBranch(repo));
  if (branch === null) {
    throw Error("An initial commit must exist!");
  }
  args = [];
  if (opts.force) {
    args.push("-f");
  }
  if (opts.upstream) {
    args.push("-u");
  }
  args.push(opts.remote || "origin");
  if (opts.branch && branch !== opts.branch) {
    args.push(branch + ":" + opts.branch);
  } else {
    args.push(branch);
  }
  if (opts.keyPath) {
    env = {};
    env.GIT_SSH_COMMAND = `ssh -i ${opts.keyPath} -F /dev/null` + (opts.debug ? " -vvv" : "");
  }
  try {
    await exec("git push", args, {
      cwd: repo,
      env: env || process.env,
      listener: opts.listener
    });
  } catch (error) {
    err = error;
    if (!opts.force) {
      if (/\(non-fast-forward\)/.test(err.message)) {
        throw Error("Must force push to overwrite remote commits!");
      }
    }
    // Detect "force updates" and normal pushes. 'git push' incorrectly prints to 'stderr'!
    regex = RegExp(`(\\+|\\s)[\\s]+([a-z0-9]{7})[\\.]{2,3}([a-z0-9]{7})[\\s]+(HEAD|${branch})[\\s]+->[\\s]+${branch}`);
    if (regex.test(err.message)) {
      return;
    }
    // Detect new branch pushes. 'git push' incorrectly prints to 'stderr'!
    regex = RegExp(`\\*[\\s]+\\[new branch\\][\\s]+${branch}[\\s]+->[\\s]+${branch}`);
    if (regex.test(err.message)) {
      return;
    }
    throw err;
  }
};
